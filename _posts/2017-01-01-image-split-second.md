---
layout: post
title: 阈值分割与区域分割
date: 2017-1-1
categories: blog
tags: [图像处理]
description: 图像分割
---


**本文主要包括以下内容**    

- 阈值分割技术
- 基于区域的图像分割技术
- 本章的典型案例
	+ 基于LoG和Canny算子的精确边缘检测
	+ 基于Hough变换的直线检测
	+ 图像的四叉树分解

### 阈值分割     
我们曾在3.5节学习过灰度阈值变换的相关知识， 利用灰度阈值变换分割图像就称为阈值分割， 它是一种基本的图像分割方法。       
阙值分割的基本思想是确定一个阈值， 然后把每个像素点的灰度值和阈值相比较，根据比较的结果把该像素划分为两类：前景或者背景，阈值分割可以分成以下3步：      

- 确定阈值．
- 将阈值和像素比较，．
- 把像素归类  

其中第1步阈值最重要。阈值的选择将直接影响分割的准确性以及由此产生的图像描述，分析的正确性。

#### 阈值分割方法
阈值分割常用的方法一般有以下几种。      

**实验法**       
实验法是通过人眼的观察， 对已知某些特征的图像， 只要试验不同的阈值， 然后看是否满足已知特征即可。这种方法的不足在于适用范围窄，
使用前必须了解图像的某些特征， 譬如平均灰度等，而且分割后图像质量的好坏受主观局限性很大。      

**根据直方图谷底确定阈值**        
如果图像的前景物体内部和背景区域的灰度值分布都比较均匀， 那么这个图像的灰度直方图将具有明显双峰， 此时可以选择两峰之间的谷底作为阈值。
其表达式为：        
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p1.png)  
注意：由于直方图是各灰度的像素统计，其峰值和谷底特性不一定代表目标和背景．因此，如果没有图像其他方面的知识，只靠直方图进行图像分割不一定准确 ．

**迭代选择阈值法**        
迭代式阈值选择方法的基本思想是：开始选择一个阈值作为初始估计值，然后按照某种规则不断地更新这一估计值，直到满足给定的条件为止。这个过程的关键在于选择怎么样的 迭代规则。一个好的迭代规则必须既能够快速收敛，又能够在每一个迭代过程中产生优于上次迭代的结果。下面是一种迭代选择阈值算法：     
(1)选择一个T的初始估计值。      
(2)利用阈值T把图像分为两个区域R1, 和R2       
(3)对区域R1和R2中的所有像素计算平均灰度值μ1和μ2         
(4)计算新的阈值：      
$$T=\frac{1}{2}(u_1+u_2)$$        
(5)重复步骤2-4, 直到逐次迭代所得的T值小于事先定义的参数T。        

**最小均方误差法**       
最小均方误差法也是常用的阈值分割法之一。这种方法通常以图像中的灰度为模式特征，假设各模式的灰度是独立分布的随机变量，并假设图像中待分割的模式服从一定的概率分布。一般来说，采用的是正态分布，即高斯概率分布。       
首先假设一幅图像仅包含两个主要的灰度区域前景和背景。令z表示灰度值，p(z)表示灰度值概率密度函数的估计值。假设概率密度函数一个对应于背景的灰度值，另一个对应于图像中前景即对象的灰度值。则描述图像中整体灰度变换的混合密度函数是：             
$$p(z) = P_1p_1(z) + P_2p_2(z)$$        
其中$P_1$是前景中具有值z的像素出现的概率，$P_2$是背景中具有值z的像素出现的概率，两者的关系为：         
$$P_1+P_2=1$$        
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p2.png) 
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p3.png) 

**最大类间方差法**      
在对图像进行阈值分割时，选定的分割阈值应使前景区域的平均灰度、背景区域的平均灰度与整幅图像的平均灰度之间差别最大，这种差异用区域的方差来表示。由此，Otsu在1978年提出了最大方差法。该算法在判决分析最小二乘法原理的基础上推导得出，计算过程简单是一种稳定、常用的算法。   
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p4.png)   
让T在[O,L-1]范围内依次取值， 使类间方差最大的T值便是最佳区域分割阈值。               
该方法不需要人为设定其他参数，是一种自动选择阈值的方法，而且能得到较好的结果。它不仅适用于包含两个区域的单阈值选择，也同样适用于多区域的多阈值选择。

#### Matlab实现      

**最大类间方差法**     
Matlab中和阙值变换相关的两个主要函数是im2bw和graythresh。实际上，利用graythresh函数即可实现最大类间方差法。        

**迭代选择阈值法**      

```
function [Ibw, thres] = autothreshold(I)
% 迭代法自动阈值分割
%
% 输入：I - 要进行自动阈值分割的灰度图像
% 输出：Ibw - 分割后的二值图像
%      thres - 自动分割采用的阈值

thres = 0.5 * (double(min(I(:))) + double(max(I(:)))); %初始阈值
done = false; %结束标志
while ~done
	g = I >= thres;
	Tnext = 0.5 * (mean(I(g)) + mean(I(~g)));
	done = abs(thres - Tnext) < 0.5;
	thres = Tnext;
end;

Ibw = im2bw(I, thres/255); % 二值化
```

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p5.png)  

### 区域分割      
前面所讲的图像分割方法都是基于像素的灰度来进行阈值分割， 本节将讨论以区域为基础的图像分割技术。传统的区域分割方法有区域生长和区域分裂与合井， 其中最基础的是区域生长法。     

#### 区域生长及其实现     
区域生长是根据事先定义的准则将像素或者子区域聚合成更大区域的过程。其基本思想是从一组生长点开始（生长点可以是单个像素，也可以为某个小区域），将与该生长点性质相似的相邻像素或者区域与生长点合并，形成新的生长点，重复此过程直到不能生长为止。生长点和相邻区域的相似性判据可以是灰度值、纹理、颜色等多种图像信息。

**区域生长算法**       
区域生长一般有3个步骤。     
(1)选择合适的生长点。       
(2)确定相似性准则即生长准则。        
(3)确定生长停止条件。                               
一般来说， 在无像素或者区域满足加入生长区域的条件时， 区域生长就会停止。
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p6.png) 
上述方法比较的是单个像素与其邻域的灰度特征以实现区域生长，也有一种混合型区域生长把图像分割成若干小区域，比较相邻小区域的相似性，如果相似则合并。在实际中，区 域生长时经常还要考虑到生长的”历史”，还要根据区域的尺寸、形状等图像的全局性质来决定区域的合并。

matlab实现    

```
function J = regionGrow(I)
% 区域生长，需要以交互方式设定初始种子点，具体方法为鼠标单击图像中一点后，按下回车键
%
% 输入：I - 原图像
% 输出：J - 输出图像

if isinteger(I)
    I=im2double(I);
end
figure,imshow(I),title('原始图像')
[M,N]=size(I);
[y,x]=getpts;             %获得区域生长起始点
x1=round(x);            %横坐标取整
y1=round(y);            %纵坐标取整
seed=I(x1,y1);           %将生长起始点灰度值存入seed中
J=zeros(M,N);          %作一个全零与原图像等大的图像矩阵J，作为输出图像矩阵
J(x1,y1)=1;             %将J中与所取点相对应位置的点设置为白
sum=seed;              %储存符合区域生长条件的点的灰度值的和
suit=1;                 %储存符合区域生长条件的点的个数
count=1;               %记录每次判断一点周围八点符合条件的新点的数目
threshold=0.15;         %阈值，注意需要和double类型存储的图像相符合
while count>0
    s=0;                   %记录判断一点周围八点时，符合条件的新点的灰度值之和
     count=0;
     for i=1:M
       for j=1:N
         if J(i,j)==1
          if (i-1)>0 & (i+1)<(M+1) & (j-1)>0 & (j+1)<(N+1)  %判断此点是否为图像边界上的点
           for u= -1:1                               %判断点周围八点是否符合阈值条件
            for v= -1:1
              if  J(i+u,j+v)==0 & abs(I(i+u,j+v)-seed)<=threshold& 1/(1+1/15*abs(I(i+u,j+v)-seed))>0.8
                           J(i+u,j+v)=1;
                    %判断是否尚未标记，并且为符合阈值条件的点
                    %符合以上两条件即将其在J中与之位置对应的点设置为白
                 count=count+1;
                 s=s+I(i+u,j+v);                      %此点的灰度之加入s中
              end
            end
           end
          end
         end
       end
     end
    suit=suit+count;                                   %将n加入符合点数计数器中
    sum=sum+s;                                     %将s加入符合点的灰度值总合中
    seed=sum/suit;                                    %计算新的灰度平均值
end
```
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p7.png) 
选择不同的生长点，结果不同。     

#### 区域分裂与合并      
区域生长是从一组生长点开始的，另一种方法是在开始时将图像分割为一系列任意不相交的区域， 然后将它们合并或者拆分以满足限制条件， 这就是区域分裂与合并。 通过分裂， 可以将不同特征的区域分离开， 而通过合并， 可以将相同特征的区域合并起来。      

**区域分裂与合并算法**     
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p8.png) 
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter92/p9.png) 
图像先分裂为如图9.22Ca)所示；第二次分裂时，如图(b)所示，由于左下角区域满足$P(R_i)=TRUE$,则不进行分裂操作；第三次分裂时，如图(c)所示，仅仅右边的突出部分 $P(R_i)=FALSE$, 需要进行分裂操作，其余不变，完成后，分裂停止；最后，对两个相邻区域 实行合并，一直得到最后的结果，如图(d)所示。                                          
区域分裂与合并对分割复杂的场景图像比较有效，如果引入应用领域知识，则可以更好地提高分割效果。     

