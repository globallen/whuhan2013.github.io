---
layout: post
title: 形态学图像处理
date: 2016-12-28
categories: blog
tags: [图像处理]
description: 形态学图像处理
---

形态学，即数学形态学(mathematical Morphology），是图像处理中应用最为广泛的技术之一，主要用于从图像中提取对表达和描绘区域形状有意义的图像分量，使后续的识别工作能够抓住目标对象最为本质〈最具区分能力－most discriminative）的形状特征，如边界和连通区域等。同时像细化、像素化和修剪毛刺等技术也常应用于图像的预处理和后处理中，成为图像增强技术的有力补充。

**本文主要包括以下内容**    

- 二值图像的基本形态学运算， 包括腐蚀、膨胀、开和闭。
- 二值形态学的经典应用， 包括击中击不中变换、边界提取和跟踪、区域填充、提取连通分量、细化和像素化， 以及凸壳
- 灰度图像的形态学运算， 包括灰度腐蚀、灰度膨胀、灰度开和灰度闭
- 本章的典型案例分析
  + 在人脸局部图像中定位嘴的中心
  + 显微镜下图像的细菌计数
  + 利用顶帽变换（top-hat）技术解决光照不均问题  

**预备知识**     
在数字图像处理中， 形态学是借助集合论的语言来描述的， 本章后面的各节内容均以本集合论为基础。  
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter8/p1.png)

**结构元素（structure element)**     
设有两幅图像A, S。若A是被处理的对象， 而S是用来处理A的， 则称S为结构元素。结构元素通常都是一些比较小的图像， A与S的关系类似于滤波中图像和模板的关系．  

### 二值图像中的基本形态学运算    
本节介绍几种二值图像的基本形态学运算， 包括腐蚀、膨胀， 以及开、闭运算。由于所有形态学运算都是针对图像中的前景物体进行的， 因而首先对图像前景和背景的认定给出必要的说明．  

注意： 大多数图像，一般相对于背景而言物体的颜色（灰度）更深， 二值化之后物体会成为黑色， 而背景则成为白色， 因此我们通常是习惯于将物体用黑色（灰度值0）表示， 而背景用白色（灰度值255）表示，本章所有的算法示意图以及所有的Visual C＋＋的程序实例都遵从这种约定；但Matlab 在二位图像形态学处理中，默认情况下白色的（二位图像中灰度值为1的像素，或灰度图像中灰度值为255的像素）
是前景（物体），黑色的为背景， 因而本章涉及Matlab 的所有程序实例又都遵从Matlab本身的这种前景认定习惯．     

实际上， 无论以什么灰度值为前景和背景都只是一种处理上的习惯， 与形态学算法本身无关。例如对于上面两幅图片， 只需要在形态学处理之前先对图像反色就可以在两种认定习惯之间自由切换。       

#### 腐蚀及其实现
腐蚀和膨胀是两种最基本也是最重要的形态学运算， 它们是后续要介绍的很多高级形态学处理的基础， 很多其他的形态学算法都是由这两种基本运算复合而成  
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter8/p2.png)

**matlab实现**       
Matlab中与腐蚀相关的两个常用函数为imerode和strel。      
imerode函数用于完成图像腐蚀．其常用调用形式如下:I2 = imrode(I,SE)     
I为原始图像，可以是二位或灰度图像（对应于灰度腐蚀）．      
SE是由strel函数返回的自定义或预设的结构元素对象．

strel函数可以为各种常见形态学运算生成结构元素SE， 当生成供二值形态学使用的结构元素肘， 其调用形式为:SE=strl(shape,parameter)    
shape指定了结构元素的形状， 其常用合法取值如在8.1所示．        
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter8/p3.png)  

腐蚀的作用“ 顾名思义，腐蚀能够消融物体的边界，而具体的腐蚀结果与图像本身和结构元素的形状有关。如果物体整体上大于结构元素，腐蚀的结构是使物体变“ 瘦”一圈，而
这一圈到底有多大是由结构元素决定的：如果物体本身小于结构元素， 则在腐蚀后的图像中物体将完全消失：如物体仅有部分区域小于结构元素〈如细小的连通3，则腐蚀后物体会在细
连通处断裂，分离为两部分。      

```
I = imread('erode_dilate.bmp');    
se = strel('square',3);
Ib = imerode(I,se);
se = strel([0 1 0;1 1 1;0 1 0]);    
Ic = imerode(I,se);
se = strel('square',5);
Id = imerode(I,se);

figure;
subplot(2,2,1);
imshow(I);
subplot(2,2,2);
imshow(Ib);
subplot(2,2,3);
imshow(Ic);
subplot(2,2,4);
imshow(Id);
```
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter8/p4.png)  

随着腐蚀结构元素的逐步增大，小于结构元素的物体相继消失。由于腐蚀运算具有上述的特点，可以用于滤波。选择适当大小和形状的结构元素，可以滤除掉所有不能 完全包含结构元素的噪声点。然而，利用腐蚀滤除噪声有一个缺点，即在去除噪声点的同时，对图像中前景物体的形状也会有影响，但当我们只关心物体的位置或者个数时，则影响不大            

#### 膨胀及其实现     
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter8/p5.png)  

实际上， 膨胀和腐蚀对子集合求补和反射运算是彼此对偶的.      
这里值得注意的是定义中要求和A有公共交集的不是结构元素S本身， 而是S的反射集， 觉得熟悉吗？这在形式上似乎容易让我们回忆起卷积运算， 而腐蚀在形式上则更像相关运算。由于图8.8 中使用的是对称的结构元素， 故使用S 和$S^'$ 的膨胀结果相同：但对于图8.9中非对称结构元素的膨胀示例， 则会产生完全不同的结果， 因此在实现膨胀运算时一定要先计算$S^'$          

**matlab实现**     
imdilate函数用于完成图像膨胀， 其常用调用形式如下：      
I2 = imdilate(I,SE);        
I为原始图像， 可以是二位或灰度图像（对应于灰度膨胀）．       
SE是由strel函数返回的自定义或预设的结构元素对象      

膨胀的作用和腐蚀相反， 膨胀能使物体边界扩大， 具体的膨胀结果与图像本身和结构元素的形状有关。膨胀常用于将图像中原本断裂开来的同一物体桥接起来， 对图像进行二值化之后， 很容易使一个连通的物体断裂为两个部分， 而这会给后续的图像分析（如要基于连通区域的分析统计物体的个数〉造成困扰，此时就可借助膨胀桥接断裂的缝隙        

```
I = imread('starcraft.bmp');
Ie1 = imerode(I,[1 1 1;1 1 1;1 1 1]);     
Ie2 = imerode(Ie1,[0 1 0;1 1 1;0 1 0]); 
Id1 = imdilate(Ie2,[1 1 1;1 1 1;1 1 1]);
Id2 = imdilate(Id1,[0 1 0;1 1 1;0 1 0]);

figure;
subplot(2,2,1);
imshow(Ie1);
subplot(2,2,2);
imshow(Ie2);
subplot(2,2,3);
imshow(Id1);
subplot(2,2,4);
imshow(Id2);
```
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter8/p6.png)

