---
layout: post
title: 逻辑回归与正则化
date: 2016-12-3
categories: blog
tags: [机器学习]
description: 逻辑回归与正则化
---

在分类问题中,你要预测的变量 y 是离散的值,我们将学习一种叫做逻辑回归 (Logistic Regression) 的算法,这是目前最流行使用最广泛的一种学习算法。

在分类问题中,我们尝试预测的是结果是否属于某一个类(例如正确或错误)。分类问 题的例子有:判断一封电子邮件是否是垃圾邮件;判断一次金融交易是否是欺诈;之前我们 也谈到了肿瘤分类问题的例子,区别一个肿瘤是恶性的还是良性的。

我们可以用逻辑回归来解决分类问题     

#### 假说表示     
我们引入一个新的模型,逻辑回归,该模型的输出变量范围始终在 0 和 1 之间。 逻辑 回归模型的假设是:$hθ(x)=g(θ^TX)$       
X 代表特征向量
g 代表逻辑函数(logistic function)是一个常用的逻辑函数为 S 形函数(Sigmoid function),      
公式为:$g(z)=\frac{1}{1+e^{-z}}$      

该函数的图像为:    

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class3/p1.png)

**判定边界**      
在逻辑回归中,我们预测:     
当 hθ 大于等于 0.5 时,预测 y=1      
当 hθ 小于 0.5 时,预测 y=0 根据上面绘制出的 S 形函数图像,我们知道当 z=0 时 g(z)=0.5      
z>0 时 g(z)>0.5      
z<0 时 g(z)<0.5       
又 $z=θ^TX$,即:            

$θ^TX$ 大于等于 0 时,预测 y=1     
$θ^TX$ 小于 0 时,预测 y=0      


**代价函数**       
在这段视频中,我们要介绍如何拟合逻辑回归模型的参数θ。具体来说,我要定义用来 拟合参数的优化目标或者叫代价函数,这便是监督学习问题中的逻辑回归模型的拟合问题。
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class3/p2.png)

对于线性回归模型,我们定义的代价函数是所有模型误差的平方和。理论上来说,我们 也可以对逻辑回归模型沿用这个定义,但是问题在于,当我们将逻辑回归
代入时， 这样定义了的代价函数中时,我们得到的代价函数将是一个非凸函数(non-convex function)       
这意味着我们的代价函数有许多局部最小值,这将影响梯度下降算法寻找全局最小值。

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class3/p3.png)       

这样构建的 Cost(hθ(x),y)函数的特点是:当实际的 y=1 且 hθ 也为 1 时误差为 0,当 y=1 但 hθ 不为 1 时误差随着 hθ 的变小而变大;当实际的 y=0 且 hθ 也为 0 时代价为 0,当 y=0 但 hθ 不为 0 时误差随着 hθ 的变大而变大。


**简化的成本函数和梯度下降**        

在这段视频中,我们将会找出一种稍微简单一点的方法来写代价函数,来替换我们现在 用的方法。同时我们还要弄清楚如何运用梯度下降法,来拟合出逻辑回归的参数。因此,听 了这节课,你就应该知道如何实现一个完整的逻辑回归算法。

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class3/p4.png)     

最小化代价函数的方法,是使用梯度下降法(gradient descent)。这是我们的代价函数:

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class3/p5.png)   

现在,如果你把这个更新规则和我们之前用在线性回归上的进行比较的话,你会惊讶地 发现,这个式子正是我们用来做线性回归梯度下降的。
那么,线性回归和逻辑回归是同一个算法吗?要回答这个问题,我们要观察逻辑回归看 看发生了哪些变化。实际上,假设的定义发生了变化。

对于线性回归假设函数: $h_\theta(x)=\Theta^TX$    
而现在逻辑函数假设函数: $h_\theta(x)=\frac{1}{1+e^{-\theta^TX}}$    


**高级优化**      

现在我们换个角度来看什么是梯度下降,我们有个代价函数 J(θ),而我们想要使其最小 化,那么我们需要做的是编写代码,当输入参数 θ 时,它们会计算出两样东西:J(θ) 以及 J 等于 0、1 直到 n 时的偏导数项

假设我们已经完成了可以实现这两件事的代码,那么梯度下降所做的就是反复执行这些 更新。
另一种考虑梯度下降的思路是:我们需要写出代码来计算 J(θ) 和这些偏导数,然后把 这些插入到梯度下降中,然后它就可以为我们最小化这个函数。
对于梯度下降来说,我认为从技术上讲,你实际并不需要编写代码来计算代价函数 J(θ)。 你只需要编写代码来计算导数项,但是,如果你希望代码还要能够监控这些 J(θ) 的收敛性.那么我们就需要自己编写代码来计算代价函数 J(θ)和偏导数项 

然而梯度下降并不是我们可以使用的唯一算法,还有其他一些算法,更高级、更复杂。      

如果我们能用这些方法来计算代价函数 J(θ)和偏导数项两个项的话,那么这些算   j
法就是为我们优化代价函数的不同方法,      

- 共轭梯度法 
- BFGS (变尺度法) 
- L-BFGS (限制变尺 度法)     

就是其中一些更高级的优化算法,它们需要有一种方法来计算 J(θ),以及需要一种方 法计算导数项,然后使用比梯度下降更复杂的算法来最小化代价函数。这三种算法的具体细 节超出了本门课程的范畴。实际上你最后通常会花费很多天,或几周时间研究这些算法,你 可以专门学一门课来 高数值计算能力,不过让我来告诉你他们的一些特性:

这三种算法有许多优点:
一个是使用这其中任何一个算法,你通常不需要手动选择学习率 α,所以对于这些算法 的一种思路是,给出计算导数项和代价函数的方法,你可以认为算法有一个智能的内部循环, 而且,事实上,他们确实有一个智能的内部循环,称为线性搜索(line search)算法,它可以自 动尝试不同的学习速率 α,并自动选择一个好的学习速率 α,因此它甚至可以为每次迭代选 择不同的学习速率,那么你就不需要自己选择。这些算法实际上在做更复杂的事情,而不仅 仅是选择一个好的学习率,所以它们往往最终收敛得远远快于梯度下降,这些算法实际上在 做更复杂的事情,不仅仅是选择一个好的学习速率,所以它们往往最终比梯度下降收敛得快 多了,不过关于它们到底做什么的详细讨论,已经超过了本门课程的范围。


高级优化matlab实现      

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class3/p6.png)   

如果我们不知道最小值,但你想要代价函数找到这个最小值,是用比如梯度下降这些算
法,但最好是用比它更高级的算法,你要做的就是运行一个像这样的 matlab 函数:

```
function [jVal, gradient]=costFunction(theta)
jVal=(theta(1)-5)^2+(theta(2)-5)^2; 
gradient=zeros(2,1); 
gradient(1)=2*(theta(1)-5); 
gradient(2)=2*(theta(2)-5);
end
```

这样就计算出这个代价函数,函数返回的第二个值是梯度值,梯度值应该是一个 2×1 的向量,梯度向量的两个元素对应这里的两个偏导数项,运行这个 costFunction 函数后,你 就可以调用高级的优化函数,这个函数叫 fminunc,它表示 Octave 里无约束最小化函数。 调用它的方式如下

```
options=optimset('GradObj','on','MaxIter',100);
initialTheta=zeros(2,1);
[optTheta, functionVal, exitFlag]=fminunc(@costFunction, initialTheta, options);
```

你要设置几个 options,这个 options 变量作为一个数据结构可以存储你想要的 options,
所以 GradObj 和 On,这里设置梯度目标参数为打开(on),这意味着你现在确实要给这个算
法 供一个梯度,然后设置最大迭代次数,比方说 100,我们给出一个 θ 的猜测初始值,它
是一个 2×1 的向量,那么这个命令就调用 fminunc,这个@符号表示指向我们刚刚定义的
costFunction 函数的指针。如果你调用它,它就会使用众多高级优化算法中的一个,当然你 也可以把它当成梯度下降,只不过它能自动选择学习速率 α,你不需要自己来做。然后它会 尝试使用这些高级的优化算法,就像加强版的梯度下降法,为你找到最佳的 θ 值。



