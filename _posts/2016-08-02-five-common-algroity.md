---
layout: post
title: 五大常用算法
date: 2016-8-2
categories: blog
tags: [数据结构]
description: 各类学习资源
---   


#### 分治算法                            
在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
 
任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。

**基本思想及策略**
 
分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。
 
分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。
 
如果原问题可分割成k个子问题，1<k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。


**分治法的基本步骤**
 
分治法在每一层递归上都有三个步骤：
 
step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

step3 合并：将各个子问题的解合并为原问题的解。
 
它的一般的算法设计模式如下：
 
Divide-and-Conquer(P)

1. if P≤n0

2. then return(ADHOC(P))

3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。



#### 动态规划              
动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
 
**基本思想与策略**
 
基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。


**适用的情况**
 
能采用动态规划求解的问题的一般要具有3个性质：
 
(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
 
(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
 
（3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）             

**实例**       
[动态规划：从新手到专家 - hackersun007的修行之路 - 博客频道 - CSDN.NET）](http://blog.csdn.net/doc_sgl/article/details/9026405)

一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。

```
#include <iostream>
using namespace std;

int lis(int A[], int n){
    int *d = new int[n];
    int len = 1;
    for(int i=0; i<n; ++i){
        d[i] = 1;
        for(int j=0; j<i; ++j)
            if(A[j]<=A[i] && d[j]+1>d[i])
                d[i] = d[j] + 1;
        if(d[i]>len) len = d[i];
    }
    delete[] d;
    return len;
}
int main(){
    int A[] = {
        5, 3, 4, 8, 6, 7
    };
    cout<<lis(A, 6)<<endl;
    return 0;
}
```

**动态规划之背包问题**           
[动态规划之背包问题（一）](http://www.hawstein.com/posts/dp-knapsack.html)       

话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i] 。排好后这哥们开始思考： 背包总共也就只能装下体积为C的东西，那我要装下哪些宝石才能让我获得最大的利益呢？


```
/**0-1 knapsack d(i, j)表示前i个物品装到剩余容量为j的背包中的最大重量**/
#include<cstdio>
using namespace std;
#define MAXN 1000
#define MAXC 100000

int V[MAXN], W[MAXN];
int d[MAXN][MAXC];

int main(){
	freopen("data.in", "r", stdin);//重定向输入流
	freopen("data.out", "w", stdout);//重定向输出流
	int n, C;
	while(scanf("%d %d", &n, &C) != EOF){
		for(int i=0; i<n; ++i)	scanf("%d %d", &V[i], &W[i]);
		
		for(int i=0; i<=n; ++i){
			for(int j=0; j<=C; ++j){
				d[i][j] = i==0 ? 0 : d[i-1][j];
				if(i>0 && j>=V[i-1])	d[i][j] >?= d[i-1][j-V[i-1]]+W[i-1];
			}
		}
		printf("%d\n", d[n][C]);//最终求解的最大价值
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```



#### 贪心算法                    
所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。
 
贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。
 
所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。


**贪心算法的基本思路：**
 
1.建立数学模型来描述问题。

2.把求解的问题分成若干个子问题。

3.对每一子问题求解，得到子问题的局部最优解。

4.把子问题的解局部最优解合成原来解问题的一个解。
 



三、贪心算法适用的问题
 
贪心策略适用的前提是：局部最优策略能导致产生全局最优解。
 
实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。

值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。
 
贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。
 
可惜的是，它需要证明后才能真正运用到题目的算法中。
 
一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。


#### 回溯法               

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
 
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
 
许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。


**基本思想**
 
在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。
 
若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。
 
而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束


**算法框架**      

```
int a[n];   
try(int i)   
{   
    if(i>n)   
       输出结果;   
     else   
    {   
       for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径   
       {  
            if(fun(j))                 // 满足限界函数和约束条件  
              {  
                 a[i] = j;  
               ...                         // 其他操作  
                 try(i+1);  
               回溯前的清理工作（如a[i]置空值等）;  
               }  
          }  
      }  
 }
```

**8皇后问题**           

```
 #include<iostream>
#include <cmath>
usingnamespace std;

void PrintResult(int*arr,int n)
{
    for (int i=1; i!= n+ 1;++i)
         cout <<"("<< i << ","<< arr[i]<< ")"<<"";
     cout << endl;
}

bool Verify(int*arr,int i)
{
    /* 和前面的i - 1行比较，看当前放置位置是否合法？*/
    for (int k = 1; k != i;++k)
        if (arr[k]== arr[i]|| abs(i - k)== abs(arr[i]- arr[k]))
            returnfalse;
    return true;
}
/* 虽然只用了一个一维数组，但是其中已经保存了足够的信息。
因为每一行只能放一个皇后，所以一维数组的第i个位置存放的
是在第i行的哪一列（第j列）上放置了皇后。这个递归函数
每次处理一行，直到第n行（下标从1开始）。*/
void NQueens(int*arr,int i, int n)
{
    /* 尝试着在第i行的第j列放置一个皇后。*/
    for (int j = 1; j != n+1;++j)
     {
         arr[i] = j;
        if (Verify(arr, i))
         {
            /* 这个递归程序的结束条件是第n行放置完毕，
             所以，当递归函数从调用NQueens(arr, i + 1, n)返回时，
             就是回到了第i行，继续搜索合适的位置。当第i + 1行的
             所有位置都不能满足的时候，上面的调用就会返回，也就
             是进行了所谓的回溯。这个回溯不需要显示的恢复以前的
             调用环境，因为所需要的信息没有被破坏。*/
            if (i== n)
                 PrintResult(arr, n);
            else
                 NQueens(arr, i +1, n);//下一行放置皇后
         }
     }
}

int main()
{
    int n;
     cin >> n;
    int *arr =newint[n +1];
     NQueens(arr, 1, n);

    return 0;
}
```


#### 分支限界法        

类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。
 
（1）分支搜索算法
 
所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。
 
选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。
 
1）FIFO搜索
 
2）LIFO搜索
 
3）优先队列式搜索

**分支限界法的一般过程**
 
由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。

分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。

分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。
 
**回溯法和分支限界法的一些区别**
 
有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？
 
回溯法和分支限界法的一些区别：
 
方法对解空间树的搜索方式       存储结点的常用数据结构      结点存储特性常用应用
 
回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解
 
分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解


**参考链接**           

[经典算法 - 随笔分类 - 红脸书生 - 博客园](http://www.cnblogs.com/steven_oyj/category/246990.html)

