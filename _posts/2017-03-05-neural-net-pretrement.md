---
layout: post
title: 神经网络数据预处理，正则化与损失函数
date: 2017-3-5
categories: blog
tags: [计算机视觉]
description: 计算机视觉
---


本文主要包括以下内容          

- 设置数据和模型
	+ 数据预处理
	+ 权重初始化
	+ 批量归一化（Batch Normalization）
	+ 正则化（L2/L1/Maxnorm/Dropout）
- 损失函数
- 小结

#### 设置数据和模型    
在上一节中介绍了神经元的模型，它在计算内积后进行非线性激活函数计算，神经网络将这些神经元组织成各个层。这些做法共同定义了评分函数（score function）的新形式，该形式是从前面线性分类章节中的简单线性映射发展而来的。具体来说，神经网络就是进行了一系列的线性映射与非线性激活函数交织的运算。本节将讨论更多的算法设计选项，比如数据预处理，权重初始化和损失函数。

#### 数据预处理
在卷积神经网处理图像问题的时候，图像数据有3种常见的预处理可能会用到，如下。我们假定数据表示成矩阵为X，其中我们假定X是[N*D]维矩阵(N是样本数据量，D为单张图片的数据向量长度)。             

- 去均值，这是最常见的图片数据预处理，简单说来，它做的事情就是，对待训练的每一张图片的特征，都减去全部训练集图片的特征均值，这么做的直观意义就是，我们把输入数据各个维度的数据都中心化到0了。使用python的numpy工具包，这一步可以用X -= np.mean(X, axis = 0)轻松实现。当然，其实这里也有不同的做法：简单一点，我们可以直接求出所有像素的均值，然后每个像素点都减掉这个相同的值；稍微优化一下，我们在RGB三个颜色通道分别做这件事。
- 归一化，归一化的直观理解含义是，我们做一些工作去保证所有的维度上数据都在一个变化幅度上。通常我们有两种方法来实现归一化。一个是在数据都去均值之后，每个维度上的数据都除以这个维度上数据的标准差(X /= np.std(X, axis = 0))。另外一种方式是我们除以数据绝对值最大值，以保证所有的数据归一化后都在-1到1之间。多说一句，其实在任何你觉得各维度幅度变化非常大的数据集上，你都可以考虑归一化处理。不过对于图像而言，其实这一步反倒可做可不做，因为大家都知道，像素的值变化区间都在[0,255]之间，所以其实图像输入数据天生幅度就是一致的。

上述两个操作对于数据的作用，画成示意图，如下：
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/cs231n/chapter6/p1.jpeg)

PCA和白化/whitening，这是另外一种形式的数据预处理。在经过去均值操作之后，我们可以计算数据的协方差矩阵，从而可以知道数据各个维度之间的相关性，简单示例代码如下：

```
# 假定输入数据矩阵X是[N*D]维的
X -= np.mean(X, axis = 0) # 去均值
cov = np.dot(X.T, X) / X.shape[0] # 计算协方差
```

数据协方差矩阵的第(i, j)个元素是数据第i个和第j个维度的协方差。具体来说，该矩阵的对角线上的元素是方差。还有，协方差矩阵是对称和半正定的。我们可以对数据协方差矩阵进行SVD（奇异值分解）运算。

```
U,S,V = np.linalg.svd(cov)
```

U的列是特征向量，S是装有奇异值的1维数组（因为cov是对称且半正定的，所以S中元素是特征值的平方）。为了去除数据相关性，将已经零中心化处理过的原始数据投影到特征基准上：

```
Xrot = np.dot(X,U) # 对数据去相关性
```

这么理解一下可能更好，U是一组正交基向量。所以我们可以看做把原始数据X投射到这组维度保持不变的正交基底上，从而也就完成了对原始数据的去相关。如果去相关之后你再求一下Xrot的协方差矩阵，你会发现这时候的协方差矩阵是一个对角矩阵了。而numpy中的np.linalg.svd更好的一个特性是，它返回的U是对特征值排序过的，这也就意味着，我们可以用它进行降维操作。我们可以只取top的一些特征向量，然后做和原始数据做矩阵乘法，这个时候既降维减少了计算量，同时又保存下了绝大多数的原始数据信息，这就是所谓的主成分分析/PCA：

```
Xrot_reduced = np.dot(X, U[:,:100]) # Xrot_reduced 变成 [N x 100]
```


这个操作之后，我们把原始数据集矩阵从[N*D]降维到[N*100]，保存了前100个能包含绝大多数数据信息的维度。实际应用中，你在PCA降维之后的数据集上，做各种机器学习的训练，在节省空间和时间的前提下，依旧能有很好的训练准确度。


最后一个在实践中会看见的变换是**白化**（whitening）。白化操作的输入是特征基准上的数据，然后对每个维度除以其特征值来对数值范围进行归一化。该变换的几何解释是：如果数据服从多变量的高斯分布，那么经过白化后，数据的分布将会是一个均值为零，且协方差相等的矩阵。该操作的代码如下：

```
# 对数据进行白化操作:
# 除以特征值 
Xwhite = Xrot / np.sqrt(S + 1e-5)
```

提个醒：whitening操作会有严重化噪声的可能。注意到我们在上述代码中，分母的部分加入了一个很小的数1e-5，以防止出现除以0的情况。但是数据中的噪声部分可能会因whitening操作而变大，因为这个操作的本质是把输入的每个维度都拉到差不多的幅度，那么本不相关的有微弱幅度变化的噪声维度，也被拉到了和其他维度同样的幅度。当然，我们适当提高的安全因子(1e-5)可以在一定程度上缓解这个问题。

下图为原始数据到去相关到白化之后的数据分布示意图： 
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/cs231n/chapter6/p2.jpeg)

我们来看看真实数据集上的操作与得到的结果，也许能对这些过程有更清晰一些的认识。大家都还记得CIFAR-10图像数据集吧。训练集大小为50000*3072，也就是说，每张图片都被展成一个3072维度的列向量了。然后我们对原始50000*3072数据矩阵做SVD分解，进行上述一些操作，再可视化一下，得到的结果示意图如下：
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/cs231n/chapter6/p3.jpeg)

最左：一个用于演示的集合，含49张图片。左二：3072个特征值向量中的前144个。靠前面的特征向量解释了数据中大部分的方差，可以看见它们与图像中较低的频率相关。第三张是49张经过了PCA降维处理的图片，展示了144个特征向量。这就是说，展示原始图像是每个图像用3072维的向量，向量中的元素是图片上某个位置的像素在某个颜色通道中的亮度值。而现在每张图片只使用了一个144维的向量，其中每个元素表示了特征向量对于组成这张图片的贡献度。为了让图片能够正常显示，需要将144维度重新变成基于像素基准的3072个数值。因为U是一个旋转，可以通过乘以U.transpose()[:144,:]来实现，然后将得到的3072个数值可视化。可以看见图像变得有点模糊了，这正好说明前面的特征向量获取了较低的频率。然而，大多数信息还是保留了下来。最右：将“白化”后的数据进行显示。其中144个维度中的方差都被压缩到了相同的数值范围。然后144个白化后的数值通过乘以U.transpose()[:144,:]转换到图像像素基准上。现在较低的频率（代表了大多数方差）可以忽略不计了，较高的频率（代表相对少的方差）就被夸大了。

实际工程中，因为这个部分讲到数据预处理，我们就把基本的几种数据预处理都讲了一遍，但实际卷积神经网中，我们并没有用到去相关和whitening操作。当然，去均值是非常非常重要的，而每个像素维度的归一化也是常用的操作。

**常见错误**       
进行预处理很重要的一点是：任何预处理策略（比如数据均值）都只能在训练集数据上进行计算，算法训练完毕后再应用到验证集或者测试集上。例如，如果先计算整个数据集图像的平均值然后每张图片都减去平均值，最后将整个数据集分成训练/验证/测试集，那么这个做法是错误的。应该怎么做呢？应该先分成训练/验证/测试集，只是从训练集中求图片平均值，然后各个集（训练/验证/测试集）中的图像再减去这个平均值。

#### 权重初始化



