---
layout: post
title: 空间域图像增强
date: 2016-12-22
categories: blog
tags: [图像处理]
description: 空间域图像增强
---

图像增强是数字图像处理相对简单却最具艺术性的领域之一，增强的目的是消除噪声，
显现那些被模糊了的细节或简单突出一幅图像中我们感兴趣的特征。一个简单例子是增强图
像的对比度， 使其看起来更加一目了然。增强是图像处理中非常主观的领域， 它以怎样构成
好的增强效果这种人为主观偏好为基础， 也正是这一点为其赋予了艺术性。这与图像复原技
术刚好相反， 图像复原也是改进图像外貌的一个处理领域， 但它是客观的。     

**本文主要包括以下内容**     

- 空间域滤波的基础知识
- 相关和卷积
- 图像平滑， 包括平均平滑和高斯平滑



### 图像增强基础     

**为什么要进行图像增强**     
图像增强是指根据特定的需要突出一幅图像中的某些信息， 同时削弱或去除某些不需要
的信息的处理方法。其主要目的是使处理后的图像对某种特定的应用来说， 比原始图像更适
用。因此， 这类处理是为了某种应用目的而去改善图像质量的。处理的结果使图像更适合人
的观察或机器的识别系统。        
应该明确地是增强处理并不能增强原始图像的信息， 其结果只能增强对某种信息的辨别
能力， 而同时这种处理有可能损失一些其他信息。正因如此， 我们很难找到一个评价图像增
强效果优劣的客观标准， 也就没有特别通用模式化的图像增强方法， 这需要我们根据具体期
望的处理效果做出取舍。      

**图像增强的分类**     
图像增强技术基本上可分成两大类: 一类是空间域增强， 另一类是频率域增强。本章着
重介绍空问域增强技术， 下一意讲述频率域图像增强。

空间域图像增强技术主要包括直方图修正、灰度变换增强、图像平滑化以及图像锐化等。
在增强过程中可以采用单一方法处理， 但更多实际情况是需要采用几种方法联合处理， 才能
达到预期的增强效果（某个单一的图像处理方法可以解决全部问题〉。

在第3 章中通过灰度变换改善图像外观的方法， 以及3.7 节和3.8 节中的直方图灰度修
正技术〈即直方图均衡化和直方图规定化〉都是图像增强的有效手段， 它们的共同点在于变
换是直接针对像素灰度值的， 与该像素所处的邻域无关， 而空间域增强则是基于图像中每一
个小范围（邻域〉内的像素进行灰度变换运算， 某个点变换之后的灰度由该点邻域之内的那
些点的灰度值共同决定， 因此空间域增强也称为邻域运算或邻域滤波。空间域变换可使用
下式描述：        
g(x,y)=T[f(x,y)]      

#### 空间域滤波     
滤波是信号处理中的一个概念， 是将信号中特定波段频率滤除的操作， 在数字信号处理
中通常采用傅立叶变换及其逆变换实现。由于下面要学习的内容实际上和通过傅立叶变换实
现的频域下的滤波是等效的， 故而也称为滤波。空间域滤波主要直接基于邻域〈空间域〉对
图像中像素执行计算，我们使用空间域滤波这一术语以区别第6 章中将要讨论的频率域滤波。

**空间域滤波和邻域处理**      
对图像中的每一点（x, y）， 重复下面的操作:     
(1) 对预先定义的以（x, y） 为中心的邻域内的像素进行运算。     
(2）将（2）中运算的结果作为（x, y）点的新响应。       
上述过程就称为邻域处理或空间域滤波。一幅数字图像可以看成一个二维函数为f(x,y)，
而x-y平面表明了空间位置信息， 称为空间域， 基于x-y 空间邻域的滤波操作称作空间域滤
波． 如果邻域中的像素计算为线性运算， 则又称为线性空间域滤波， 否则称为非线性空间域
滤液。     

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p1.png)
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p2.png)
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p3.png)

**边界处理**     
执行滤波操作需注意当模板位于图像边缘时，需要对边缘附近的那些元素执行滤波操作单独处理，以避免引用到本不属于图像的无意义的值（在Matlab中这将引起系统的警告，而在vc中很可能会由于非法访问内存而产生运行错误〉。      

以下3种策略都可以用来解决边界问题：      
(1）收缩处理范围一处理时忽略位于图像f 边界附近会引起问题的那些点， 如对于
图5.1中所使用的模板， 处理时忽略图像f 四周一圈1个像素宽的边界， 即只处理从x =
1，2 ,3, ... .M-2和y = 1,2,3, .. .N-2 （在Matlab中应为x = 2,3,4, ... ,M-1和y = 2,3,4, ... N-1）范围内
的点， 从而确保了滤被过程中模板始终不会超出图像f 的边界。       
(2）使用常数填充图像一根据模板形状为图像f 虚拟出边界． 虚拟边界像素值为指定
的常数， 如0， 得到虚拟图像f ’。保证模板在移动过程中始终不会超出f ’的边界。       
(3）使用复制像素的方法填充图像,和（2）基本相同， 只是用来填充虚拟边界像素
值的不是固定的常数， 而是复制图像f本身边界的模式．         
这些技巧在本章后面的小节程序设计实例中将给出具体实现。  

**相关和卷积**    
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p4.png)   

**图像处理之卷积概念**    
我们来看一下一维卷积的概念.          
连续空间的卷积定义是 f(x)与g(x)的卷积是 f(t-x)g(x) 在t从负无穷到正无穷的积分值.t-x要在f(x)定义域内,所以看上去很大的积分实际上还是在一定范围的.                
实际的过程就是f(x) 先做一个Y轴的反转,然后再沿X轴平移t就是f(t-x),然后再把g(x)拿来,两者乘积的值再积分.想象一下如果g(x)或者f(x)是个单位的阶越函数. 那么就是f(t-x)与g(x)相交部分的面积.这就是卷积了.            
把积分符号换成求和就是离散空间的卷积定义了.   


对于图像而言，离散卷积的计算过程是模板翻转，然后在原图像上滑动模板，把对应位置上的元素相乘后加起来，得到最终的结果。如果不考虑翻转，这个滑动-相乘-叠加的过程就是相关操作。事实上我也一直用相关来理解卷积。在时域内可以从两个角度来理解这样做的含义。

一种是滤波，比如最简单的高斯模板，就是把模板内像素乘以不同的权值然后加起来作为模板的中心像素值，如果模板取值全为1，就是滑动平均；如果模板取值为高斯，就是加权滑动平均，权重是中间高，四周低，在频率上理解就是低通滤波器；如果模板取值为一些边缘检测的模板，结果就是模板左边的像素减右边的像素，或者右边的减左边的，得到的就是图像梯度，方向不同代表不同方向的边缘；

另一种理解是投影，因为当前模板内部图像和模板的相乘累加操作就是图像局部patch和模板的内积操作，如果把patch和模板拉直，拉直的向量看成是向量空间中的向量，那么这个过程就是patch向模板方向上的投影，一幅图像和一个模板卷积，得到的结果就是图像各个patch在这个方向上的response map或者feature map；如果这样的模板有一组，我们可以把这一组看成一组基，得到的一组feature map就是原图像在这组基上的投影。常见的如用一组Garbor滤波器提取图像的特征，以及卷积神经网络中的第一层，图像在各个卷积核上的投影。

我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性。也就是说使用卷积就是为了提取显著特征，减少特征维数，减少计算量。

在对图像进行卷积操作后的主观印象：图像变得模糊了，可是我们依然能够分辨出是什么！所以卷积就是提取显著特征！（个人理解，简单明了）

**滤波操作的Matlab实现**   
Matlab中与滤披相关的函数主要有imfilter和fspecial. imfilter完成滤波操作，而fspecial
可以为我们创建一些预定义的2维滤波器， 直接供imfilter函数使用．  

滤波函数imfilter    
函数原型如下：   
g =imfilter(f,w,optional1,optional2);    

参数说明          
• f是要进行滤波操作的图像．
• w是滤波操作所使用的模板，为一个二维数组．     
• option 1, option2, ... 是可选项， 具体可以包括：  

(1）边界选项： 主要针对5.2.2 小节中提到的边界处理问题， 如表5.1所示。
采用第一种方式用固定值填充虚拟边界会使边缘附近会产生梯度， 采用后面三种方式填
充可让边缘显得平滑。     
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p5.png) 

```
f = imread('cameraman.tif');
w = [1,1,1;1,1,1;1,1,10]/9;
g = imfilter(f,w,'corr','replicate');
figure;
subplot(1,2,1);
imshow(f),title('原图像');   
subplot(1,2,2);
imshow(g),title('滤波操作');
```
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p6.png) 

**fspecial创建预定义的二维滤波器**     
其调用格式如下     
h = fspecial(type,paramaters)    

参数说明：     
参数type用于指定滤波器的类型，其中一些类型的滤波器将在5.3节和5.4节中介绍，有些则将放到第9章的图像分割中介绍，作为边缘检测的算子.type的一些合法值 如表5.4所示．        
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p7.png) 
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p8.png) 


### 图像平滑
图像平滑是一种可以减少和抑制图像噪声的实用数字图像处理技术。在空间域中一般可以采用邻域平均来达到平滑的目的。           

#### 平均模板及其实现
从图5.2滤波前后的效果对比可以看出滤波后的图g有平滑或者说模糊的效果， 这完全
是模板w作用的结果。例5.1中的w提供了一种平均的加权模式， 首先在以点（x, y ） 为中
心，3×3邻域内的点都参与了决定新图像g中(x,y）点像素值的运算：而且所有系数都为1
表示它们在参与决定g (x, y） 值的过程中贡献(权重)相同：而前面的系数则保证了整个
模板元素和为1, 这里应为1/9， 这样就能让新图像和原始图像一样， 保持在一个灰度范围中
〈如（0, 255］）. 这样的w叫做平均模板， 是用于使图像平滑的模板中的一种， 相当于一种局
部平均。更一般的平均模板为：      
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p9.png) 

**工作原理**     
一般来说，图像具有局部连续性质，即相邻像素的数值相近，而噪声的存在使得在噪声
点处产生灰度跳跃，但一般我们可以合理地假设偶尔出现的噪声影响并没有改变图像局部连
续的性质，例如下面的局部图像f_sub，灰色底纹标识的为噪声点，在图像中表现为亮区中的
2个暗点:      
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p10.png) 

显然，通过平滑滤波原局部图像f_sub中噪声点的灰度值得到了有效修正，像这样将每
一个点用周围点的平均替代从而达到减少噪声影响的过程就称为平滑或模糊．    

Matlab实现    

```
I = imread('baby_noise.bmp');
h = fspecial('average',3);
I3 = imfilter(I,h,'corr','replicate');
h = fspecial('average',5);
I5 = imfilter(I,h,'corr','replicate');
h = fspecial('average',7);
I7 = imfilter(I,h,'corr','replicate');
figure;
subplot(2,2,1);
imshow(I),title('原图');

subplot(2,2,2);
imshow(I3),title('3*3');
subplot(2,2,3);
imshow(I5),title('5*5');
subplot(2,2,4);
imshow(I7),title('7*7');
```
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p11.png) 

上述程序的运行效果如图 5.3 所示， 可以看出随着模板的增大， 滤波过程在平滑更多噪声的同时也使得图像变得越来越模糊，这是由平均模板的工作机理决定的。当模板增大到7×7时， 图像中的某些细节，如衣服上的褶皱已经难以辨识了， 纽扣也变得相当模糊。 实际 上， 当图像细节与滤波器模板大小相近时， 图像细节就会受到比较大的影响， 尤其当它们的灰度值比较接近时， 混合效应导致的图像模糊会更明显。 随着模板地进一步增大， 像纽扣这样的细节都会被当作噪声平滑掉． 因此， 我们在确定模板尺寸时应仔细考虑要滤除的噪声点的大小， 有针对性地进行滤波．  

#### 高斯平滑及其实现    
平均平滑对邻域内的像素一视同仁， 为了减少平滑处理中的模糊， 得到更自然的平滑效
果， 则会很自然地想到适当加大模板中心点的权重， 随着远离中心点， 权重迅速减小， 从而
可以确保中心点看起来更接近与它距离更近的点， 基于这种考虑得到的模板即为高斯模板。
常用的3×3的高斯模板如下所示：
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p12.png) 
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p13.png) 

matlab实现   

```
I = imread('baby_noise.bmp');
h3_5 = fspecial('gaussian',3,0.5);
I3_5 = imfilter(I,h3_5);

h3_8 = fspecial('gaussian',3,0.8);
I3_8 = imfilter(I,h3_8);
h3_18 = fspecial('gaussian',3,1.8);
I3_18 = imfilter(I,h3_18);

h5_8 = fspecial('gaussian',5,0.8);
I5_8 = imfilter(I,h5_8);

h7_12 = fspecial('gaussian',7,1.2);
I7_12 = imfilter(I,h7_12);

figure;
subplot(2,3,1);
imshow(I);
subplot(2,3,2);
imshow(I3_5);
subplot(2,3,3);
imshow(I3_8);
subplot(2,3,4);
imshow(I3_18);
subplot(2,3,5);
imshow(I5_8);
subplot(2,3,6);
imshow(I7_12);
```

上面介绍的平均平滑施波器和高斯平滑滤波器都是线性平滑滤波器， 在学习频率域滤波
之后， 还可以为它们赋予另外一个名字一一低通滤波器。    

#### 自适应平滑滤波     
利用平均模板的平滑消除噪声的同时也会使图像变得模糊． 高斯平滑在一定程度上缓解
了这些现象， 但由平滑滤波机理可知这种模糊是不可避免的。这当然是我们所不希望的． 于
是想到选择性地进行平滑，即只在噪声局部区域进行平滑，而在无噪声局部区域不进行平滑，
将模糊的影响降到最低， 这就是自适应滤波的思想．     

如何判断该局部区域是包含噪声需要平滑的区域还是无明显噪声不需平滑的区域？ 这
要基于噪声的性质来考虑， 5.3.1小节讨论了图像的局部连续性质， 噪声的存在导致在噪声点
处产生灰度跳跃， 从而使噪声点局部区域灰度跨度较大． 因此可以选择如下两个标准中的1
个作为局部区域存在噪声的判据：      
![](https://raw.githubusercontent.com/whuhan2013/myImage/master/dataImage/chapter5/p14.png) 
对于那些噪声位置具有随机性和局部性的图像， 自适应的滤波具有非常好的效果． 有兴
趣的读者可自己编制程序实现自适应的高斯平滑算法， 应用于具有上述特点的噪声图像中，
并且，和我们给出的标准高斯平滑效果进行比较．

