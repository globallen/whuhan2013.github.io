---
layout: post
title: 校招准备之JAVA基础
date: 2016-7-28
categories: blog
tags: [求职]
description: 
---

**1、equals与==的区别**             
1. == 是一个运算符。                               
2.Equals则是string对象的方法，可以.（点）出来。                   
 
我们比较无非就是这两种 1、基本数据类型比较 2、引用对象比较        
1、基本数据类型比较                   
==和Equals都比较两个值是否相等。相等为true 否则为false；            

2、引用对象比较          
==和Equals都是比较栈内存中的地址是否相等 。相等为true 否则为false；       

需注意几点：             
1、string是一个特殊的引用类型。对于两个字符串的比较，不管是 == 和 Equals 这两者比较的都是字符串是否相同；   
2、当你创建两个string对象时，内存中的地址是不相同的，你可以赋相同的值.      
所以字符串的内容相同。引用地址不一定相同，（相同内容的对象地址不一定相同），但反过来却是肯定的；    
3、基本数据类型比较(string 除外) == 和 Equals 两者都是比较值；         

**2、Object有哪些公用方法**        
clone、equals、hashCode、getClass、wait、notify、notifyAll、toString          
参考：[Object类有哪些公用方法？ - donghaol的专栏 - 博客频道 - CSDN.NET](http://blog.csdn.net/donghaol/article/details/49252383)                 

**3、Java的四种引用，强弱软虚，用到的场景**       

- 强引用       
强引用不会被GC回收，并且在java.lang.ref里也没有实际的对应类型，平时工作接触的最多的就是强引用。        
- 软引用        
如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

- 弱引用（WeakReference）             
如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

- 虚引用（PhantomReference）        
"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。                 
虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。            
参考：[Java的四种引用，强弱软虚，用到的场景 - To-已陌 - 博客园](http://www.cnblogs.com/yumo/p/4908416.html)       



**4、Hashcode的作用**           
总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。 
你知道它们的区别吗？前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 
那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 
这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。 
也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。           
于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 

参考：[关于hashCode方法的作用 - huxin1的专栏 - 博客频道 - CSDN.NET](http://blog.csdn.net/huxin1/article/details/6325061)                    

**5、ArrayList、LinkedList、Vector的区别**       
LinkedList 是一个双向链表，线程不安全        

ArrayList 是基于数组实现的List，线程不安全

Vector 多数方法都被synchronized修饰的List实现，线程安全；一般在遗留代码中被使用，现在不推荐。        


**6、String、StringBuffer与StringBuilder的区别**          

- 可变与不可变     
String不可变，其他两个都可变          
- 是否多线程安全         
String中的对象是不可变的，也就可以理解为常量，显然线程安全。                        
StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的                              
StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。              
- StringBuilder与StringBuffer共同点         
同一个父类，但一个线程安全，一个线程不安全，最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。


**7、Map、Set、List、Queue、Stack的特点与用法**       
Set集合类似于一个罐子，"丢进"Set集合里的多个对象之间没有明显的顺序。        
List集合代表元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。         
Stack是Vector提供的一个子类，用于模拟"栈"这种数据结构(LIFO后进先出)         
Queue用于模拟"队列"这种数据结构(先进先出 FIFO)。                             
Map用于保存具有"映射关系"的数据，因此Map集合里保存着两组值               

**8、HashMap和HashTable的区别，TreeMap、HashMap、LindedHashMap的区别**           
Hashtable是基于陈旧的Dictionary类的，HashMap是Map接口的一个实现        
Hashtable的方法是线程同步的，而HashMap的方法不是。         
只有HashMap可以让你将空值作为一个表的条目的key或value            


Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。          
LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序                                                   
TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。         







