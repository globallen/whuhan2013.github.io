---
layout: post
title: 神经网络学习
date: 2016-12-5
categories: blog
tags: [机器学习]
description: 神经网络学习
---

**代价函数**     
首先引入一些便于稍后讨论的新标记方法:
假设神经网络的训练样本有 m 个,每个包含一组输入 x 和一组输出信号 y,L 表示神经 网络层数,$S_l$ 表示每层的 neuron 个数($SL$ 表示输出层神经元个数),$S_L$ 代表最后一层中处理 单元的个数。

将神经网络的分类定义为两种情况:二类分类和多类分类, 二类分类:$S_L$=1, y=0 or 1 表示哪一类;     
K 类分类:$S_L$=K, $y_i$ = 1 表示分到第 i 类;(K>2)     

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p1.png)   


在逻辑回归中,我们只有一个输出变量,又称标量(scalar),也只有一个因变量 y,但 是在神经网络中,我们可以有很多输出变量,我们的 hθ(x)是一个维度为 K 的向量,并且我 们训练集中的因变量也是同样维度的一个向量,因此我们的代价函数会比逻辑回归更加复杂 一些,为:

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p2.png)   

这个看起来复杂很多的代价函数背后的思想还是一样的,我们希望通过代价函数来观察 算法预测的结果与真实情况的误差有多大,唯一不同的是,对于每一行特征,我们都会给出 K 个预测,基本上我们可以利用循环,对每一行特征都预测 K 个不同结果,然后在利用循环 在 K 个预测中选择可能性最高的一个,将其与 y 中的实际数据进行比较。

归一化的那一项只是排除了每一层 $θ_0$ 后,每一层的 θ 矩阵的和。最里层的循环 j 循环 所有的行(由 $s_l$ +1 层的激活单元数决定),循环 i 则循环所有的列,由该层($s_l$ 层)的激 活单元数所决定。即:hθ(x)与真实值之间的距离为每个样本-每个类输出的加和,对参数进行 regularization 的 bias 项处理所有参数的平方和。

#### 反向传播算法        
之前我们在计算神经网络预测结果的时候我们采用了一种正向传播方法,我们从第一层 开始正向一层一层进行计算,直到最后一层的 hθ(x)。     
现在,为了计算代价函数的偏导数，我们需要采用一种反向传播算法,也
就是首先计算最后一层的误差,然后再一层一层反向求出各层的误差,直到倒数第二层。 以 一个例子来说明反向传播算法。      

假设我们的训练集只有一个实例$(x^{(1)},y^{(1)})$,我们的神经网络是一个四层的神经网络, 其中 K=4,$S_L$=4,L=4:      
前向传播算法:        

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p3.png)   

我们从最后一层的误差开始计算,误差是激活单元的预测$a^{(4)}_k$与实际值(yk)之间 的误差,(k=1:K)。
我们用 δ 来表示误差,则: $δ^{(4)}=a^{(4)}-y$     

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p4.png)  

关于反向误差的计算方法可以参见：[关于第5周反向传播算法的一些争论与思考](http://mooc.guokr.com/note/16702/)      
具体数学推导可以参见：[反向传播（Backpropagation）算法的数学原理](https://my.oschina.net/findbill/blog/529001) 

$$\delta^{(l)}_j=\frac{\sigma}{\sigma(z^{(l)_j})}J(\theta)$$

重要的是清楚地知道上面式子中上下标的含义:       
l 代表目前所计算的是第几层                                       
j 代表目前计算层中的激活单元的下标,也将是下一层的第 j 个输入变量的下标。      
i 代表下一层中误差单元的下标,是受到权重矩阵中第 i 行影响的下一层中的误差单元的下标。         

如果我们考虑归一化处理,并且我们的训练集是一个特征矩阵而非向量。在上面的特殊
情况中,我们需要计算每一层的误差单元来计算代价函数的偏导数。在更为一般的情况中, 我们同样需要计算每一层的误差单元,但是我们需要为整个训练集计算误差单元,此时的误
差单元也是一个矩阵,我们用$\Delta^{(l)}_{ij}$来表示这个误差矩阵。第 l 层的第 i 个激活单元受到第 j 个参数影响而导致的误差。

我们的算法表示为:       

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p5.png) 

即首先用正向传播方法计算出每一层的激活单元,利用训练集的结果与神经网络预测的 结果求出最后一层的误差,然后利用该误差运用反向传播法计算出直至第二层的所有误差。
在求出了 $\Delta^{(l)}_{ij}$之后,我们便可以计算代价函数的偏导数了,计算方法如下:

![](https://raw.githubusercontent.com/whuhan2013/myImage/master/machineLearning/class5/p6.png) 