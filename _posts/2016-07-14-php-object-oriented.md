---
layout: post
title: PHP面向对象基础
date: 2016-7-14
categories: blog
tags: [PHP]
description: PHP
---

**基本概念**       

- 对象，object，对应现实逻辑中的一个实体，是一个实体在计算机语言的一个表示。是一个数据，与数据的操作的集合体！
- 属性，property，对象的数据
- 方法，method，对象的操作

对象怎么来的？通过实例化类而生成！    

- 类，class，使用计算机语言对一类事物的抽象。类似于图纸！用于规定某类对象的结构，但是本身不是具体对象。
- 实例化，instance，依据类的抽象定义，形成对象的操作，称之为实例化！

**构造与析构函数**    

- __construct()  
如果一个方法或者函数参数过多，或者参数不能确定时：会选择使用数组的形式完成处理：    
- __destruct



**一些常用概念**   

- 类的静态成员，static
- 类常量，const
- 继承，extends             
- instanceof，是否是某类实例
- 重写，override
- parent，父类
- self,当前类    
- this,当前对象         
- 访问修饰限定符，public，protected，private     
- 抽象类，abstract类 ,不能实例化，只能继承           
- 接口结构，interface        
- 类文件的载入-自动加载机制     
当需要一个类，当时并没有找到该类的定义，此时，PHP核心（Zend Engine），会自动尝试调用一个叫：__autoload()的函数。与此同时，会将当前所需要的类名作为参数，传递到__autoload()这个函数中。

```
/**
 * 完成需要那个类就加载那个类的定义文件
 */
function __autoload($class_name) {
  echo $class_name, '<br>';
  require './' . $class_name . '.class.php';
}
var_dump(new Book);//需要执行加载
```

**序列化，反序列化**            
存储数据时，适用于在保存，与读取时，对数据进行转换与反转换！
![](https://raw.githubusercontent.com/whuhan2013/ImageRepertory/master/php/p5.png)

- 序列化，serialize     
- 反序列化，unserialize

**对象的序列化与反序列化**              
1，在反序列化时，需要找到该对象所属的类的定义才可以，否则会变成__PHP_Incomplete_Class类的对象，不是原来的对象：
存入：                                       
因此，只要在反序列化之前，将类载入即可！  
2，反序列化，也会触发自动加载机制。           
3，在序列化时，可以自定义需要序列化的属性名单！         
通过对象的特殊的方法__sleep()                                         
该方法会在对象被序列化时，自动调用，不需要参数，需要返回一个数组，每个元素，表示一个属性名，数组内存在的属性名，就会被序列化。反之则不会被序列化！                     
4，在反序列化时，可以自动再次执行某些代码，从而完成某些资源的初始化！                
通过 对象方法：__wakeup()方法              
会在 对象被反序列过程中自动调用，所负责的功能，执行反序列话（醒来之后）的初始化工作！               


__construct     
__destruct      
__sleep       
__wakeup        

php自动调用，用户脚本只需要定义。在特定的功能调用特定的方法！这些都称为：魔术方法；


**对象的拷贝**              

对象之间的赋值，只有引用传递，没有值传递！     
保存对象的变量内，保存的不是对象本身，而是对象的标识！         

导致的结果，不能通过赋值的方式，使用旧对象，得到新对象！        

**对象的克隆**            
克隆，使用一个已有对象，得到一个属性一致的新对象！
使用 关键字 clone 来实现                  

典型在克隆时，一定会出现某些属性时用于区分是否是克隆出来的！

意味着，在克隆出来新对象时，要为新对象增加一些额外的标识才可以！
此时 ，在 执行clone时，会自动调用 新对象的魔术方法 __clone，去完成克隆对象的额外的初始化工作！


#### 重载                         
重载，overload，指的是php对当前对象的不可访问成员的处理方式！         
其中，不可访问：指的是两种，不存在的和受到访问控制访问不到的！       

**默认的处理方式：**    

1，针对不存在的属性：        
自动增加属性为公共的属性！ 

2. 针对访问权限限制的：             


**属性重载的魔术方法**       

属性的重载处理，需要使用php提供的魔术方法完成 

- __set();          
当为不可访问的属性赋值时，会被自动调用
会得到两个参数，当前操作的属性名，和属性值！
- __get();        
当访问不可访问的属性时，会被自动调用          
需要的参数是：一个，为当前操作的属性名        
- __unset()           
在删除一个不可访问的属性时，可以自动被调用！      
需要一个参数 当前操作的属性名。       
此时就可以利用业务逻辑完成 属性的删除处理！             
- __isset();         
在判断一个不可访问的属性是否存在时，被自动调用        
需要一个参数，属性名             
注意，次函数需要返回true，或者false，表示属性是否存在：              

**方法重载的魔术方法**        
__call()                                             
当访问一个不可访问的对象方法时，会触发当前的魔术方法！            

此时会触发：        
需要的参数时：             
2个参数，第一是当前的方法名，第二是调用时使用的实参列表！       

典型的作用，给出友好的提示,第二，执行默认操作！          

**static __callStatic()**        
与 __call类似，当静态调用一个不可访问的方法时，会自动执行！


**魔术方法，magic method**                   
在特定的情况下，会被自动调用的方法，通常负责完成某块独立的功能的方法称之为魔术方法！特点：1，需要用户脚本定义，不定义不执行！2，命名方式都是以__开头！

总结：
__construct        
__destruct
__sleep              
__wakeup         
__set          
__get       
__isset    
__unset      
__clone          
__call            
__callStatic             

__autoload()//魔术函数           


- __invoke()                   
将一个对象，当作函数调用时，会触发该对象的__invoke()方法，由此方法，就可以调用，没有该方法就不能调用！      

- __toString()              
转换到字符串的意思！
当将对象当作字符串使用时，会自动调用该对象的魔术方法！    


#### 对象的遍历

对象是一个集合数据类型！

**简单的遍历，foreach**                           
foreach，可以遍历对象                            
遍历对象，是依次获得对象拥有的属性的信息！         

**自定义遍历，iterator，迭代器接口**  


#### 常用的对象，类函数     

is_object();      
class_exists();            
interface_exists();             
get_class();                 
get_parent_class();         

get_class_vars();得到类的变量（属性）          
get_class_methods();得到类的方法                

get_declared_classes();得到所有已经定义的类！                
可以见，有自定义类，和预定义类！  
stdClass，内置的标准类！            

**魔术常量**               
__CLASS__，当前类名。注意：可以new self 不可以new __CLASS__。 
__METHOD__，当前方法名。区别__FUNCTION__。
__FILE__
__DIR__
__LINE__
__FUNCTION__











